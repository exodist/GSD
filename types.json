{
    "Dec": {
        "desc": "Represents a floating point number. Generally a double under the hood",
        "parent": "Object",
        "roles": [ "Scalar" ]
    },
    "Dict": {
        "desc": "The dictionary type, equivilent to perls hash, also works as an array.<p>Integer, Decimal, String and Object keys are considered different, that is 1, 1.0, and \"1\" are different keys and may each have a different value.<p>",
        "parent": "Object",
        "roles": [ "Index", "Queue", "Chainable", "Iterable", "Sequence" ],
        "methods": {
            "dereference": {
                "desc": "Remove the key from the dictionary",
                "details": "This removes the key reference in the dictionary. Neither the key nor the value remain."
            },
            "reference": {
                "desc": "Make a reference between 2 dictionaries",
                "details": "<span style='example'>dictA.reference 'mykey', dictB, 'bkey';</span><br/>This links the 'mykey' in dictA to the 'bkey' key in dictB. Updating the value of mykey in dictA updates 'bkey' in dictB, and vice-versa. Deleting the value for one also deletes the other."
            },
            "insert": {
                "desc": "Insert a new key, fails if key exists",
                "details": "Set the value for a key in the dictionary, but only if the key does not exist. If two threads insert the same key at the same time one will succeed and the other will fail. Returns true on seccess, false on failure."
            },
            "update": {
                "desc": "Set the value of an existing key, fails if key does not exist",
                "details": "The opposite of insert, updates the value, but only for existing keys."
            },
            "keys": {
                "desc": "Returns a new integer indexed dictionary where values are the keys of the first dictionary",
                "details": "Keys from the first dictionary are used as values in a new dictionary that is returned. The keys of the new dictionary will be sequencial integers. No sorting is done."
            },
            "values": {
                "desc": "Returns a new integer indexed dictionary where values are the values of the first dictionary",
                "details": "Values of the first dictionary are used as values of the new dictionary, but all keys are sequencial integers in the new dictionary."
            },
            "cmp_update": {
                "desc": "Atomic compare and swap",
                "detail": "Set a new value for an existing key, swapping it out atomically only if the value is currently set to the value we want to swap from"
            }
        }
    },
    "Graph": {
        "desc": "The Graph type represents a key/value pair. It is used frequently with dictionary types, both in iteration and construction.",
        "parent": "Object",
        "methods": {
            "key": {
                "desc": "Get the object acting as the key",
                "details": ""
            },
            "value": {
                "desc": "Get the object acting as the value",
                "details": ""
            }
        }
    },
    "Int": {
        "desc": "Represents a signed 64-bit integer number",
        "parent": "Object",
        "roles": [ "Scalar" ]
    },
    "Internal": {
        "desc": "Represents an internal function, for example a c function or system function. This is GSD's answer to XS. The unfortunate bit is that modules that make use of these will need a seperate implemenation for each GSD implementation they intend to support.",
        "parent": "Object",
        "roles": [ "Callable" ],
        "details": "Works just like a subroutine, can be called as a method, fuction, or sub."
    },
    "IO": {
        "parent": "Object",
        "roles": [ "Callable", "Refcounted" ]
    },
    "Keyword": {
        "parent": "Object"
    },
    "Lock": {
        "desc": "Returned by mutex.lock, represents a lock on a mutex. If the Lock object falls out of scope it is destroyed and the mutex is unlocked.",
        "parent": "Object",
        "roles": [ "Refcounted" ],
        "attributes": {
            "mutex": {
                "desc": "The mutex to which the lock applies"
            }
        },
        "methods": {
            "DESTROY": {
                "desc": "Releases the lock on the mutex when the Lock object is collected",
                "details": ""
            }
        }
    },
    "Mutex": {
        "desc": "Thread synchronization",
        "parent": "Object",
        "methods": {
            "lock": {
                "desc": "Aquire a lock on the mutex",
                "details": "If the block argument is true, it will block until the lock can be aquired. Returns a 'Lock' object when successful, if the Lock object falls out of scope the lock is released."
            },
            "unlock": {
                "desc": "Unlock the mutex",
                "details": "A 'Lock' object must be provided as an argument"
            }
        }
    },
    "Undef": {
        "parent": "Object"
    },
    "Object": {
        "parent": "undef",
        "methods":{
            "type": {}
        }
    },
    "Operator": {
        "parent": "Object"
    },
    "Package": {
        "parent": "Object"
    },
    "Parser": {
        "parent": "Object"
    },
    "Process": {
        "parent": "Object"
    },
    "Role": {
        "parent": "Object"
    },
    "Sigil": {
        "parent": "Object"
    },
    "Stackframe": {
        "parent": "Object"
    },
    "String": {
        "desc": "Represents a string of unicode characters",
        "parent": "Object",
        "roles": [ "Scalar" ],
        "methods": {
        }
    },
    "Subroutine": {
        "parent": "Object",
        "roles": [ "Callable" ],
        "attributes": {
            "defined_as": {
                "desc": "values are sub, method, or function",
                "detail": "The value is set by the keyword used with the block (if any)"
            },
            "defined_name": {
                "desc": "If the sub was defined using a keyword, it will have a name",
                "detail": ""
            }
        },
        "methods": {
            "filename": {},
            "start_line": {},
            "end_line": {}
        }
    },
    "Thread": {
        "parent": "Object"
    },
    "Type": { 
        "roles": [ "Callable" ],
        "parent": "Object",
        "methods": {
            "has": {},
            "can": {},
            "isa": {},
            "does": {}
        }
    }
}


