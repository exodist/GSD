{
    "Callable": {
        "desc": "Role for things that can be treated like subroutines.",
        "methods": {
            "call": {
                "desc": "How to call the object as a subroutine",
                "details": "This is what actually gets run when an instance of a callable object is called as a subroutine."
            }
        }
    },
    "Chainable": {
        "desc": "Role for chainable objects, this is similar to unix pipes, several steps work in sequence to transform input objects to output objects.",
        "requires": {
            "send": {
                "desc": "Used to add items to be processed",
                "details": "When a Chainable object is sent input, it processes/tranforms it, then passes it along to the next step in the chain. ",
                "usage": [ "obj.send input => remaining_chain_graph" ]
            }
        }
    },
    "Index": {
        "desc": "Role for types that are indexable and can use index operators",
        "details": "An index is any object that has named and/or numbered members that can be accessed. An example would be a hash table.",
        "requires": {
            "get_index": {
                "desc": "Get the value for an index",
                "details": "Gets the value for an index if it exists. Returns undef if the index is not set, throws an exception if the index is not valid.",
                "usage": [ "lex val = obj.get_index 'my_key'" ]
            },
            "set_index": {
                "desc": "Set the value for an index",
                "details": "Sets the value for an index, throws an exception if the index is not valid. Can take either a list (index, value) or a graph (index => value)",
                "usage": [ "obj.set_index 'my_key', 'val'", "obj.set_index 'my_key' => 'val'" ]
            },
            "exists": {
                "desc": "Check if an index exists",
                "details": "Returns true if all the indexes exist, can take any number of indexes.",
                "usage": [ "lex bool = obj.exists 'a', 'b', 'c', ..." ]
            },
            "delete": {
                "desc": "Remove the value from the index",
                "details": "Remove the value associated with the specified index. This will not remove a reference, but will instead unset the value of the reference.",
                "usage": [ "lex val = obj.delete 'idx'" ]
            }
        }
    },
    "Iterable": {
        "desc": "Used for types with multiple values that can be iterated, such as an array",
        "requires": {
            "iterator": {
                "desc": "Must return an object that implements the 'Iterator' role",
                "usage": [ "lex iter = obj.iterator" ]
            }
        },
        "methods": {
            "each": {
                "desc": "Runs a subroutine for each item",
                "details": "The subroutine provided as an argument is run once for each item in the structure. 'item' must ALWAYS be a graph, when the structure has both keys and values the graph will have a key and a value, if it only has values then the graph key will be undef.<p>Note: the iterator returned by the iterator method is used, you can override 'each' if you like.",
                "usage": [ "obj.each { ...item... }" ]
            }
        }
    },
    "Iterator": {
        "desc": "Role for objects used to iterate over data",
        "requires": {
            "first": {
                "desc": "Reset the iterator to the first item which it returns",
                "usage": [ "lex f = iter.first" ]
            },
            "last": {
                "desc": "Reset the iterator to the last item which it returns",
                "usage": [ "lex f = iter.last" ]
            },
            "next": {
                "desc": "Get the next item from the iterator, advances the iterator by 1",
                "usage": [ "lex i = iter.next" ]
            },
            "prev": {
                "desc": "Get the previous item from the iterator, moves the iterator back by 1",
                "usage": [ "lex i = iter.prev" ]
            }
        }
    },
    "Pattern": {
        "desc": "Role for things such as regular expression patterns",
        "requires": {
            "check": {
                "desc": "Check if the input matches the pattern",
                "detail": "Returns undef when there is no match. When there is a match this can return anything true. In many cases it might be best to return an object with details about the match, and possibly any captured sections."
            }
        }
    },
    "Queue": {
        "desc": "Role for objects that have ordered data",
        "requires": {
            "push": {
                "desc": "Push a new object to the end of the queue.",
                "usage": [ "obj.push some_obj" ]
            },
            "pop": {
                "desc": "Pop an object off the end of the queue.",
                "usage": [ "some_obj = obj.pop" ]
            },
            "shift": {
                "desc": "Push a new object to the start of the queue.",
                "usage": [ "obj.push some_obj" ]
            },
            "unshift": {
                "desc": "Pop an object off the front of the queue",
                "usage": [ "obj.push some_obj" ]
            }
        }
    },
    "Refcounted": {
        "desc": "When an object uses this role, reference counting will be used to free the object as soon as possible. Without this role GSD is free to use any method of garbage collection and there is no guarentee about when the object will be collected."
    },
    "ScalarCast": {
        "desc": "Role for objects that can be converted to scalar types",
        "requires": {
            "to_int": {
                "desc": "Returns the Integer value"
            },
            "to_dec": {
                "desc": "Returns the Decimal value"
            },
            "to_string": {
                "desc": "Returns the String value"
            }
        }
    },
    "Sequence": {
        "desc": "Role for objects that hold numbered data",
        "roles": [ "Index" ],
        "requires": {
            "get_upper_value": {
                "desc": "Get the value from the highest integer index, if an argument is provided use it as an offset."
            },
            "get_lower_value": {
                "desc": "Get the value from the lowest integer index, if an argument is provided use it as an offset."
            },
            "upper_int_index": {
                "desc": "Get the largest integer index within the dictionary",
                "details": ""
            },
            "lower_int_index": {
                "desc": "Get the smallest integer index within the dictionary",
                "details": ""
            }
        }
    }
}
